# 修改计划：提升精度、优化交互与样式

根据您的需求，我制定了以下 4 点修改计划：

## 1. 提升物理引擎精度，解决抖动
目前抖动主要是因为单次 `update` 步长过大，力变化剧烈。我们将采用 **子步 (Sub-stepping)** 技术，即在每一帧渲染中，执行多次小步长的物理计算，从而提高稳定性。
*   **修改 `src/engine/PhysicsEngine.ts`**：
    *   将 `update()` 方法重命名为 `step()`。
    *   新增 `update()` 方法，在该方法内循环调用 `step()` 多次（例如 5-10 次）。
    *   在 `step()` 中，将受力计算的系数除以子步数，或者减少单步的时间步长 `dt`。
    *   同时，将 `REPULSION`（斥力）和 `STIFFNESS`（拉力/劲度系数）**减小 30%**。

## 2. 优化节点半径与文字限制
*   **修改 `src/GraphParser.ts`**：
    *   在 `syncNode` 方法中，限制 `label` 的最大长度为 6。如果超过 6，截断并添加 `...`（或者直接截断，根据需求“限制文字长度不超过6”）。
    *   优化半径计算公式：`radius = Math.max(20, Math.min(label.length * 8, 60))`。现在的公式似乎导致半径过大，我们将调整系数，使其更紧凑地包裹文字。例如改为 `radius = Math.max(20, ctx.measureText(label).width / 2 + 10)`，需要传入 context 或估算。简单起见，用字符数估算：`radius = Math.max(20, label.length * 6 + 10)`。

## 3. 实现滚轮缩放 (Zoom)
*   **修改 `src/engine/Renderer.ts`**：
    *   添加 `scale` 属性，默认 1.0。
    *   添加 `zoom(delta)` 方法，修改 `scale`。
    *   在 `draw()` 方法中，使用 `ctx.save()`, `ctx.scale(scale, scale)`, `ctx.restore()` 来应用缩放。
    *   注意：缩放中心通常是鼠标位置或屏幕中心。为了简化，先实现以屏幕中心或左上角为基准的缩放，或者配合平移（Pan）。
    *   *更优方案*：直接在 `App.tsx` 监听滚轮事件，调用 `renderer.zoom`。

## 4. 添加刷新按钮
*   **修改 `src/App.tsx`**：
    *   在左侧面板下方添加一个“刷新”按钮 (`Button` 组件)。
    *   点击时，触发图的重新解析/生成逻辑（可以清除当前引擎状态，重新调用 `GraphParser.parse`）。

## 执行顺序
1.  **物理引擎优化**：修改 `PhysicsEngine.ts`（子步、减小力）。
2.  **节点样式优化**：修改 `GraphParser.ts`（半径、文字截断）。
3.  **渲染缩放**：修改 `Renderer.ts`。
4.  **UI 交互**：修改 `App.tsx`（滚轮监听、刷新按钮）。
5.  **验证**：构建并重启。

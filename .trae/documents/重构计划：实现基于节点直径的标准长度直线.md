# 重构计划：实现基于节点直径的标准长度直线

根据您的要求，我们将彻底重构物理引擎，将复杂的曲线（绳索模拟）替换为简单的可伸缩直线（弹簧），并根据连接节点的直径动态计算标准长度。

## 1. 移除复杂的绳索模拟
目前 `PhysicsEngine` 使用粒子链 (`particles`) 来模拟绳索，这导致了复杂的曲线效果。我们将移除这些逻辑，回归到两点之间的直接连接。

*   **修改 `src/engine/types.ts`**：
    *   移除 `Edge` 接口中的 `particles` 数组。
    *   保留并重用 `restLength` 作为“当前长度”（或者说是当前弹簧的目标长度），用于实现渐变效果。
    *   增加 `targetRestLength` 属性，存储最终计算出的标准长度。

*   **修改 `src/engine/PhysicsEngine.ts`**：
    *   **移除**：`addEdge` 中生成粒子的循环、`update` 中对粒子的受力计算和积分更新。
    *   **简化**：`update` 方法中，边的弹力计算将直接作用于 `source` 和 `target` 两个节点。

## 2. 实现标准长度计算逻辑
标准长度 = $3 \times \frac{(d_1 + d_2)}{2} = 3 \times (r_1 + r_2)$ （因为 $d = 2r$）。

*   **修改 `src/engine/PhysicsEngine.ts`**：
    *   在 `addEdge` 或 `update` 中，计算每条边的标准长度：`idealLength = 3 * (source.radius + target.radius)`。
    *   在 `update` 循环中实现**渐变逻辑**：
        *   比较边的当前 `restLength` 和 `idealLength`。
        *   每帧调整 `restLength` 向 `idealLength` 靠近（例如 `+= (ideal - current) * 0.05`），实现“趋于”的效果。
    *   **弹力计算**：使用胡克定律 `F = k * (distance - restLength)` 计算两点间的力。

## 3. 渲染层适配
*   **修改 `src/engine/Renderer.ts`**：
    *   移除绘制 `particles` 和贝塞尔曲线的代码。
    *   直接使用 `lineTo` 绘制从 `source` 到 `target` 的直线。

## 4. UI 清理
*   **修改 `src/App.tsx`**：
    *   移除“绳索段数”的滑块，因为现在是直线，不再需要分段。

## 5. 执行步骤
1.  **清理类型**：修改 `types.ts`。
2.  **重构引擎**：修改 `PhysicsEngine.ts`，移除粒子，实现新的长度逻辑。
3.  **适配渲染**：修改 `Renderer.ts`。
4.  **清理 UI**：修改 `App.tsx`。
5.  **验证**：构建并重启服务器。
